// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: necode/common/message.proto

package common

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	enums "github.com/rskvp/necode/proto/gen/necode/enums"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = enums.EncodingType(0)
)

// Validate checks the field values on DataBlob with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DataBlob) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataBlob with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DataBlobMultiError, or nil
// if none found.
func (m *DataBlob) ValidateAll() error {
	return m.validate(true)
}

func (m *DataBlob) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EncodingType

	// no validation rules for Data

	if len(errors) > 0 {
		return DataBlobMultiError(errors)
	}

	return nil
}

// DataBlobMultiError is an error wrapping multiple validation errors returned
// by DataBlob.ValidateAll() if the designated constraints aren't met.
type DataBlobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataBlobMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataBlobMultiError) AllErrors() []error { return m }

// DataBlobValidationError is the validation error returned by
// DataBlob.Validate if the designated constraints aren't met.
type DataBlobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataBlobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataBlobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataBlobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataBlobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataBlobValidationError) ErrorName() string { return "DataBlobValidationError" }

// Error satisfies the builtin error interface
func (e DataBlobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataBlob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataBlobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataBlobValidationError{}

// Validate checks the field values on Payloads with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Payloads) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Payloads with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PayloadsMultiError, or nil
// if none found.
func (m *Payloads) ValidateAll() error {
	return m.validate(true)
}

func (m *Payloads) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPayloads() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PayloadsValidationError{
						field:  fmt.Sprintf("Payloads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PayloadsValidationError{
						field:  fmt.Sprintf("Payloads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PayloadsValidationError{
					field:  fmt.Sprintf("Payloads[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PayloadsMultiError(errors)
	}

	return nil
}

// PayloadsMultiError is an error wrapping multiple validation errors returned
// by Payloads.ValidateAll() if the designated constraints aren't met.
type PayloadsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PayloadsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PayloadsMultiError) AllErrors() []error { return m }

// PayloadsValidationError is the validation error returned by
// Payloads.Validate if the designated constraints aren't met.
type PayloadsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PayloadsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PayloadsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PayloadsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PayloadsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PayloadsValidationError) ErrorName() string { return "PayloadsValidationError" }

// Error satisfies the builtin error interface
func (e PayloadsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPayloads.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PayloadsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PayloadsValidationError{}

// Validate checks the field values on Payload with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Payload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Payload with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PayloadMultiError, or nil if none found.
func (m *Payload) ValidateAll() error {
	return m.validate(true)
}

func (m *Payload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Metadata

	// no validation rules for Data

	if len(errors) > 0 {
		return PayloadMultiError(errors)
	}

	return nil
}

// PayloadMultiError is an error wrapping multiple validation errors returned
// by Payload.ValidateAll() if the designated constraints aren't met.
type PayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PayloadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PayloadMultiError) AllErrors() []error { return m }

// PayloadValidationError is the validation error returned by Payload.Validate
// if the designated constraints aren't met.
type PayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PayloadValidationError) ErrorName() string { return "PayloadValidationError" }

// Error satisfies the builtin error interface
func (e PayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PayloadValidationError{}

// Validate checks the field values on SearchAttributes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SearchAttributes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchAttributes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SearchAttributesMultiError, or nil if none found.
func (m *SearchAttributes) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchAttributes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetIndexedFields()))
		i := 0
		for key := range m.GetIndexedFields() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetIndexedFields()[key]
			_ = val

			// no validation rules for IndexedFields[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, SearchAttributesValidationError{
							field:  fmt.Sprintf("IndexedFields[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, SearchAttributesValidationError{
							field:  fmt.Sprintf("IndexedFields[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return SearchAttributesValidationError{
						field:  fmt.Sprintf("IndexedFields[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return SearchAttributesMultiError(errors)
	}

	return nil
}

// SearchAttributesMultiError is an error wrapping multiple validation errors
// returned by SearchAttributes.ValidateAll() if the designated constraints
// aren't met.
type SearchAttributesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchAttributesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchAttributesMultiError) AllErrors() []error { return m }

// SearchAttributesValidationError is the validation error returned by
// SearchAttributes.Validate if the designated constraints aren't met.
type SearchAttributesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchAttributesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchAttributesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchAttributesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchAttributesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchAttributesValidationError) ErrorName() string { return "SearchAttributesValidationError" }

// Error satisfies the builtin error interface
func (e SearchAttributesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchAttributes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchAttributesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchAttributesValidationError{}

// Validate checks the field values on Memo with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Memo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Memo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MemoMultiError, or nil if none found.
func (m *Memo) ValidateAll() error {
	return m.validate(true)
}

func (m *Memo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetFields()))
		i := 0
		for key := range m.GetFields() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetFields()[key]
			_ = val

			// no validation rules for Fields[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, MemoValidationError{
							field:  fmt.Sprintf("Fields[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, MemoValidationError{
							field:  fmt.Sprintf("Fields[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return MemoValidationError{
						field:  fmt.Sprintf("Fields[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return MemoMultiError(errors)
	}

	return nil
}

// MemoMultiError is an error wrapping multiple validation errors returned by
// Memo.ValidateAll() if the designated constraints aren't met.
type MemoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MemoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MemoMultiError) AllErrors() []error { return m }

// MemoValidationError is the validation error returned by Memo.Validate if the
// designated constraints aren't met.
type MemoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MemoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MemoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MemoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MemoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MemoValidationError) ErrorName() string { return "MemoValidationError" }

// Error satisfies the builtin error interface
func (e MemoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMemo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MemoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MemoValidationError{}

// Validate checks the field values on Header with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Header) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Header with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in HeaderMultiError, or nil if none found.
func (m *Header) ValidateAll() error {
	return m.validate(true)
}

func (m *Header) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetFields()))
		i := 0
		for key := range m.GetFields() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetFields()[key]
			_ = val

			// no validation rules for Fields[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, HeaderValidationError{
							field:  fmt.Sprintf("Fields[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, HeaderValidationError{
							field:  fmt.Sprintf("Fields[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return HeaderValidationError{
						field:  fmt.Sprintf("Fields[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return HeaderMultiError(errors)
	}

	return nil
}

// HeaderMultiError is an error wrapping multiple validation errors returned by
// Header.ValidateAll() if the designated constraints aren't met.
type HeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HeaderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HeaderMultiError) AllErrors() []error { return m }

// HeaderValidationError is the validation error returned by Header.Validate if
// the designated constraints aren't met.
type HeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HeaderValidationError) ErrorName() string { return "HeaderValidationError" }

// Error satisfies the builtin error interface
func (e HeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HeaderValidationError{}

// Validate checks the field values on WorkflowExecution with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WorkflowExecution) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkflowExecution with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WorkflowExecutionMultiError, or nil if none found.
func (m *WorkflowExecution) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkflowExecution) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WorkflowId

	// no validation rules for RunId

	if len(errors) > 0 {
		return WorkflowExecutionMultiError(errors)
	}

	return nil
}

// WorkflowExecutionMultiError is an error wrapping multiple validation errors
// returned by WorkflowExecution.ValidateAll() if the designated constraints
// aren't met.
type WorkflowExecutionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkflowExecutionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkflowExecutionMultiError) AllErrors() []error { return m }

// WorkflowExecutionValidationError is the validation error returned by
// WorkflowExecution.Validate if the designated constraints aren't met.
type WorkflowExecutionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkflowExecutionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkflowExecutionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkflowExecutionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkflowExecutionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkflowExecutionValidationError) ErrorName() string {
	return "WorkflowExecutionValidationError"
}

// Error satisfies the builtin error interface
func (e WorkflowExecutionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkflowExecution.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkflowExecutionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkflowExecutionValidationError{}

// Validate checks the field values on WorkflowType with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WorkflowType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkflowType with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WorkflowTypeMultiError, or
// nil if none found.
func (m *WorkflowType) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkflowType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return WorkflowTypeMultiError(errors)
	}

	return nil
}

// WorkflowTypeMultiError is an error wrapping multiple validation errors
// returned by WorkflowType.ValidateAll() if the designated constraints aren't met.
type WorkflowTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkflowTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkflowTypeMultiError) AllErrors() []error { return m }

// WorkflowTypeValidationError is the validation error returned by
// WorkflowType.Validate if the designated constraints aren't met.
type WorkflowTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkflowTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkflowTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkflowTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkflowTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkflowTypeValidationError) ErrorName() string { return "WorkflowTypeValidationError" }

// Error satisfies the builtin error interface
func (e WorkflowTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkflowType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkflowTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkflowTypeValidationError{}

// Validate checks the field values on ActivityType with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActivityType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActivityType with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActivityTypeMultiError, or
// nil if none found.
func (m *ActivityType) ValidateAll() error {
	return m.validate(true)
}

func (m *ActivityType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return ActivityTypeMultiError(errors)
	}

	return nil
}

// ActivityTypeMultiError is an error wrapping multiple validation errors
// returned by ActivityType.ValidateAll() if the designated constraints aren't met.
type ActivityTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActivityTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActivityTypeMultiError) AllErrors() []error { return m }

// ActivityTypeValidationError is the validation error returned by
// ActivityType.Validate if the designated constraints aren't met.
type ActivityTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActivityTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActivityTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActivityTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActivityTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActivityTypeValidationError) ErrorName() string { return "ActivityTypeValidationError" }

// Error satisfies the builtin error interface
func (e ActivityTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActivityType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActivityTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActivityTypeValidationError{}

// Validate checks the field values on RetryPolicy with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RetryPolicy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RetryPolicy with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RetryPolicyMultiError, or
// nil if none found.
func (m *RetryPolicy) ValidateAll() error {
	return m.validate(true)
}

func (m *RetryPolicy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInitialInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RetryPolicyValidationError{
					field:  "InitialInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RetryPolicyValidationError{
					field:  "InitialInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitialInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RetryPolicyValidationError{
				field:  "InitialInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BackoffCoefficient

	if all {
		switch v := interface{}(m.GetMaximumInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RetryPolicyValidationError{
					field:  "MaximumInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RetryPolicyValidationError{
					field:  "MaximumInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaximumInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RetryPolicyValidationError{
				field:  "MaximumInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MaximumAttempts

	if len(errors) > 0 {
		return RetryPolicyMultiError(errors)
	}

	return nil
}

// RetryPolicyMultiError is an error wrapping multiple validation errors
// returned by RetryPolicy.ValidateAll() if the designated constraints aren't met.
type RetryPolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RetryPolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RetryPolicyMultiError) AllErrors() []error { return m }

// RetryPolicyValidationError is the validation error returned by
// RetryPolicy.Validate if the designated constraints aren't met.
type RetryPolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RetryPolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RetryPolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RetryPolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RetryPolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RetryPolicyValidationError) ErrorName() string { return "RetryPolicyValidationError" }

// Error satisfies the builtin error interface
func (e RetryPolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRetryPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RetryPolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RetryPolicyValidationError{}

// Validate checks the field values on MeteringMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MeteringMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeteringMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeteringMetadataMultiError, or nil if none found.
func (m *MeteringMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *MeteringMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NonfirstLocalActivityExecutionAttempts

	if len(errors) > 0 {
		return MeteringMetadataMultiError(errors)
	}

	return nil
}

// MeteringMetadataMultiError is an error wrapping multiple validation errors
// returned by MeteringMetadata.ValidateAll() if the designated constraints
// aren't met.
type MeteringMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeteringMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeteringMetadataMultiError) AllErrors() []error { return m }

// MeteringMetadataValidationError is the validation error returned by
// MeteringMetadata.Validate if the designated constraints aren't met.
type MeteringMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeteringMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeteringMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeteringMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeteringMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeteringMetadataValidationError) ErrorName() string { return "MeteringMetadataValidationError" }

// Error satisfies the builtin error interface
func (e MeteringMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeteringMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeteringMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeteringMetadataValidationError{}

// Validate checks the field values on WorkerVersionStamp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WorkerVersionStamp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkerVersionStamp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WorkerVersionStampMultiError, or nil if none found.
func (m *WorkerVersionStamp) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkerVersionStamp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BuildId

	// no validation rules for BundleId

	// no validation rules for UseVersioning

	if len(errors) > 0 {
		return WorkerVersionStampMultiError(errors)
	}

	return nil
}

// WorkerVersionStampMultiError is an error wrapping multiple validation errors
// returned by WorkerVersionStamp.ValidateAll() if the designated constraints
// aren't met.
type WorkerVersionStampMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkerVersionStampMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkerVersionStampMultiError) AllErrors() []error { return m }

// WorkerVersionStampValidationError is the validation error returned by
// WorkerVersionStamp.Validate if the designated constraints aren't met.
type WorkerVersionStampValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkerVersionStampValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkerVersionStampValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkerVersionStampValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkerVersionStampValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkerVersionStampValidationError) ErrorName() string {
	return "WorkerVersionStampValidationError"
}

// Error satisfies the builtin error interface
func (e WorkerVersionStampValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkerVersionStamp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkerVersionStampValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkerVersionStampValidationError{}

// Validate checks the field values on WorkerVersionCapabilities with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WorkerVersionCapabilities) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkerVersionCapabilities with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WorkerVersionCapabilitiesMultiError, or nil if none found.
func (m *WorkerVersionCapabilities) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkerVersionCapabilities) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BuildId

	// no validation rules for UseVersioning

	if len(errors) > 0 {
		return WorkerVersionCapabilitiesMultiError(errors)
	}

	return nil
}

// WorkerVersionCapabilitiesMultiError is an error wrapping multiple validation
// errors returned by WorkerVersionCapabilities.ValidateAll() if the
// designated constraints aren't met.
type WorkerVersionCapabilitiesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkerVersionCapabilitiesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkerVersionCapabilitiesMultiError) AllErrors() []error { return m }

// WorkerVersionCapabilitiesValidationError is the validation error returned by
// WorkerVersionCapabilities.Validate if the designated constraints aren't met.
type WorkerVersionCapabilitiesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkerVersionCapabilitiesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkerVersionCapabilitiesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkerVersionCapabilitiesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkerVersionCapabilitiesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkerVersionCapabilitiesValidationError) ErrorName() string {
	return "WorkerVersionCapabilitiesValidationError"
}

// Error satisfies the builtin error interface
func (e WorkerVersionCapabilitiesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkerVersionCapabilities.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkerVersionCapabilitiesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkerVersionCapabilitiesValidationError{}
