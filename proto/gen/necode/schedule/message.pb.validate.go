// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: necode/schedule/message.proto

package schedule

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	enums "github.com/rskvp/necode/proto/gen/necode/enums"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = enums.ScheduleOverlapPolicy(0)
)

// Validate checks the field values on CalendarSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CalendarSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CalendarSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CalendarSpecMultiError, or
// nil if none found.
func (m *CalendarSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *CalendarSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Second

	// no validation rules for Minute

	// no validation rules for Hour

	// no validation rules for DayOfMonth

	// no validation rules for Month

	// no validation rules for Year

	// no validation rules for DayOfWeek

	// no validation rules for Comment

	if len(errors) > 0 {
		return CalendarSpecMultiError(errors)
	}

	return nil
}

// CalendarSpecMultiError is an error wrapping multiple validation errors
// returned by CalendarSpec.ValidateAll() if the designated constraints aren't met.
type CalendarSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CalendarSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CalendarSpecMultiError) AllErrors() []error { return m }

// CalendarSpecValidationError is the validation error returned by
// CalendarSpec.Validate if the designated constraints aren't met.
type CalendarSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CalendarSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CalendarSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CalendarSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CalendarSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CalendarSpecValidationError) ErrorName() string { return "CalendarSpecValidationError" }

// Error satisfies the builtin error interface
func (e CalendarSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCalendarSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CalendarSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CalendarSpecValidationError{}

// Validate checks the field values on Range with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Range) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Range with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RangeMultiError, or nil if none found.
func (m *Range) ValidateAll() error {
	return m.validate(true)
}

func (m *Range) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Start

	// no validation rules for End

	// no validation rules for Step

	if len(errors) > 0 {
		return RangeMultiError(errors)
	}

	return nil
}

// RangeMultiError is an error wrapping multiple validation errors returned by
// Range.ValidateAll() if the designated constraints aren't met.
type RangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RangeMultiError) AllErrors() []error { return m }

// RangeValidationError is the validation error returned by Range.Validate if
// the designated constraints aren't met.
type RangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RangeValidationError) ErrorName() string { return "RangeValidationError" }

// Error satisfies the builtin error interface
func (e RangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RangeValidationError{}

// Validate checks the field values on StructuredCalendarSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StructuredCalendarSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StructuredCalendarSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StructuredCalendarSpecMultiError, or nil if none found.
func (m *StructuredCalendarSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *StructuredCalendarSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSecond() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StructuredCalendarSpecValidationError{
						field:  fmt.Sprintf("Second[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StructuredCalendarSpecValidationError{
						field:  fmt.Sprintf("Second[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StructuredCalendarSpecValidationError{
					field:  fmt.Sprintf("Second[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetMinute() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StructuredCalendarSpecValidationError{
						field:  fmt.Sprintf("Minute[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StructuredCalendarSpecValidationError{
						field:  fmt.Sprintf("Minute[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StructuredCalendarSpecValidationError{
					field:  fmt.Sprintf("Minute[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetHour() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StructuredCalendarSpecValidationError{
						field:  fmt.Sprintf("Hour[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StructuredCalendarSpecValidationError{
						field:  fmt.Sprintf("Hour[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StructuredCalendarSpecValidationError{
					field:  fmt.Sprintf("Hour[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDayOfMonth() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StructuredCalendarSpecValidationError{
						field:  fmt.Sprintf("DayOfMonth[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StructuredCalendarSpecValidationError{
						field:  fmt.Sprintf("DayOfMonth[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StructuredCalendarSpecValidationError{
					field:  fmt.Sprintf("DayOfMonth[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetMonth() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StructuredCalendarSpecValidationError{
						field:  fmt.Sprintf("Month[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StructuredCalendarSpecValidationError{
						field:  fmt.Sprintf("Month[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StructuredCalendarSpecValidationError{
					field:  fmt.Sprintf("Month[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetYear() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StructuredCalendarSpecValidationError{
						field:  fmt.Sprintf("Year[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StructuredCalendarSpecValidationError{
						field:  fmt.Sprintf("Year[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StructuredCalendarSpecValidationError{
					field:  fmt.Sprintf("Year[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDayOfWeek() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StructuredCalendarSpecValidationError{
						field:  fmt.Sprintf("DayOfWeek[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StructuredCalendarSpecValidationError{
						field:  fmt.Sprintf("DayOfWeek[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StructuredCalendarSpecValidationError{
					field:  fmt.Sprintf("DayOfWeek[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Comment

	if len(errors) > 0 {
		return StructuredCalendarSpecMultiError(errors)
	}

	return nil
}

// StructuredCalendarSpecMultiError is an error wrapping multiple validation
// errors returned by StructuredCalendarSpec.ValidateAll() if the designated
// constraints aren't met.
type StructuredCalendarSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StructuredCalendarSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StructuredCalendarSpecMultiError) AllErrors() []error { return m }

// StructuredCalendarSpecValidationError is the validation error returned by
// StructuredCalendarSpec.Validate if the designated constraints aren't met.
type StructuredCalendarSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StructuredCalendarSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StructuredCalendarSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StructuredCalendarSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StructuredCalendarSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StructuredCalendarSpecValidationError) ErrorName() string {
	return "StructuredCalendarSpecValidationError"
}

// Error satisfies the builtin error interface
func (e StructuredCalendarSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStructuredCalendarSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StructuredCalendarSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StructuredCalendarSpecValidationError{}

// Validate checks the field values on IntervalSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IntervalSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IntervalSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IntervalSpecMultiError, or
// nil if none found.
func (m *IntervalSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *IntervalSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IntervalSpecValidationError{
					field:  "Interval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IntervalSpecValidationError{
					field:  "Interval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IntervalSpecValidationError{
				field:  "Interval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPhase()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IntervalSpecValidationError{
					field:  "Phase",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IntervalSpecValidationError{
					field:  "Phase",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPhase()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IntervalSpecValidationError{
				field:  "Phase",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return IntervalSpecMultiError(errors)
	}

	return nil
}

// IntervalSpecMultiError is an error wrapping multiple validation errors
// returned by IntervalSpec.ValidateAll() if the designated constraints aren't met.
type IntervalSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IntervalSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IntervalSpecMultiError) AllErrors() []error { return m }

// IntervalSpecValidationError is the validation error returned by
// IntervalSpec.Validate if the designated constraints aren't met.
type IntervalSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IntervalSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IntervalSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IntervalSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IntervalSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IntervalSpecValidationError) ErrorName() string { return "IntervalSpecValidationError" }

// Error satisfies the builtin error interface
func (e IntervalSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIntervalSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IntervalSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IntervalSpecValidationError{}

// Validate checks the field values on ScheduleSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScheduleSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScheduleSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScheduleSpecMultiError, or
// nil if none found.
func (m *ScheduleSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ScheduleSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetStructuredCalendar() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ScheduleSpecValidationError{
						field:  fmt.Sprintf("StructuredCalendar[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ScheduleSpecValidationError{
						field:  fmt.Sprintf("StructuredCalendar[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScheduleSpecValidationError{
					field:  fmt.Sprintf("StructuredCalendar[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCalendar() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ScheduleSpecValidationError{
						field:  fmt.Sprintf("Calendar[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ScheduleSpecValidationError{
						field:  fmt.Sprintf("Calendar[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScheduleSpecValidationError{
					field:  fmt.Sprintf("Calendar[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInterval() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ScheduleSpecValidationError{
						field:  fmt.Sprintf("Interval[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ScheduleSpecValidationError{
						field:  fmt.Sprintf("Interval[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScheduleSpecValidationError{
					field:  fmt.Sprintf("Interval[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetExcludeCalendar() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ScheduleSpecValidationError{
						field:  fmt.Sprintf("ExcludeCalendar[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ScheduleSpecValidationError{
						field:  fmt.Sprintf("ExcludeCalendar[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScheduleSpecValidationError{
					field:  fmt.Sprintf("ExcludeCalendar[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetExcludeStructuredCalendar() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ScheduleSpecValidationError{
						field:  fmt.Sprintf("ExcludeStructuredCalendar[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ScheduleSpecValidationError{
						field:  fmt.Sprintf("ExcludeStructuredCalendar[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScheduleSpecValidationError{
					field:  fmt.Sprintf("ExcludeStructuredCalendar[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleSpecValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleSpecValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleSpecValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleSpecValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleSpecValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleSpecValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetJitter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleSpecValidationError{
					field:  "Jitter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleSpecValidationError{
					field:  "Jitter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJitter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleSpecValidationError{
				field:  "Jitter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TimezoneName

	// no validation rules for TimezoneData

	if len(errors) > 0 {
		return ScheduleSpecMultiError(errors)
	}

	return nil
}

// ScheduleSpecMultiError is an error wrapping multiple validation errors
// returned by ScheduleSpec.ValidateAll() if the designated constraints aren't met.
type ScheduleSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScheduleSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScheduleSpecMultiError) AllErrors() []error { return m }

// ScheduleSpecValidationError is the validation error returned by
// ScheduleSpec.Validate if the designated constraints aren't met.
type ScheduleSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScheduleSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScheduleSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScheduleSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScheduleSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScheduleSpecValidationError) ErrorName() string { return "ScheduleSpecValidationError" }

// Error satisfies the builtin error interface
func (e ScheduleSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScheduleSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScheduleSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScheduleSpecValidationError{}

// Validate checks the field values on SchedulePolicies with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SchedulePolicies) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SchedulePolicies with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SchedulePoliciesMultiError, or nil if none found.
func (m *SchedulePolicies) ValidateAll() error {
	return m.validate(true)
}

func (m *SchedulePolicies) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OverlapPolicy

	if all {
		switch v := interface{}(m.GetCatchupWindow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SchedulePoliciesValidationError{
					field:  "CatchupWindow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SchedulePoliciesValidationError{
					field:  "CatchupWindow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCatchupWindow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SchedulePoliciesValidationError{
				field:  "CatchupWindow",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PauseOnFailure

	if len(errors) > 0 {
		return SchedulePoliciesMultiError(errors)
	}

	return nil
}

// SchedulePoliciesMultiError is an error wrapping multiple validation errors
// returned by SchedulePolicies.ValidateAll() if the designated constraints
// aren't met.
type SchedulePoliciesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SchedulePoliciesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SchedulePoliciesMultiError) AllErrors() []error { return m }

// SchedulePoliciesValidationError is the validation error returned by
// SchedulePolicies.Validate if the designated constraints aren't met.
type SchedulePoliciesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SchedulePoliciesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SchedulePoliciesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SchedulePoliciesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SchedulePoliciesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SchedulePoliciesValidationError) ErrorName() string { return "SchedulePoliciesValidationError" }

// Error satisfies the builtin error interface
func (e SchedulePoliciesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSchedulePolicies.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SchedulePoliciesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SchedulePoliciesValidationError{}

// Validate checks the field values on ScheduleAction with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScheduleAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScheduleAction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScheduleActionMultiError,
// or nil if none found.
func (m *ScheduleAction) ValidateAll() error {
	return m.validate(true)
}

func (m *ScheduleAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Action.(type) {
	case *ScheduleAction_StartWorkflow:
		if v == nil {
			err := ScheduleActionValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStartWorkflow()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ScheduleActionValidationError{
						field:  "StartWorkflow",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ScheduleActionValidationError{
						field:  "StartWorkflow",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartWorkflow()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScheduleActionValidationError{
					field:  "StartWorkflow",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ScheduleActionMultiError(errors)
	}

	return nil
}

// ScheduleActionMultiError is an error wrapping multiple validation errors
// returned by ScheduleAction.ValidateAll() if the designated constraints
// aren't met.
type ScheduleActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScheduleActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScheduleActionMultiError) AllErrors() []error { return m }

// ScheduleActionValidationError is the validation error returned by
// ScheduleAction.Validate if the designated constraints aren't met.
type ScheduleActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScheduleActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScheduleActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScheduleActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScheduleActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScheduleActionValidationError) ErrorName() string { return "ScheduleActionValidationError" }

// Error satisfies the builtin error interface
func (e ScheduleActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScheduleAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScheduleActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScheduleActionValidationError{}

// Validate checks the field values on ScheduleActionResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ScheduleActionResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScheduleActionResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ScheduleActionResultMultiError, or nil if none found.
func (m *ScheduleActionResult) ValidateAll() error {
	return m.validate(true)
}

func (m *ScheduleActionResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetScheduleTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleActionResultValidationError{
					field:  "ScheduleTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleActionResultValidationError{
					field:  "ScheduleTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScheduleTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleActionResultValidationError{
				field:  "ScheduleTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetActualTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleActionResultValidationError{
					field:  "ActualTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleActionResultValidationError{
					field:  "ActualTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActualTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleActionResultValidationError{
				field:  "ActualTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStartWorkflowResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleActionResultValidationError{
					field:  "StartWorkflowResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleActionResultValidationError{
					field:  "StartWorkflowResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartWorkflowResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleActionResultValidationError{
				field:  "StartWorkflowResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ScheduleActionResultMultiError(errors)
	}

	return nil
}

// ScheduleActionResultMultiError is an error wrapping multiple validation
// errors returned by ScheduleActionResult.ValidateAll() if the designated
// constraints aren't met.
type ScheduleActionResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScheduleActionResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScheduleActionResultMultiError) AllErrors() []error { return m }

// ScheduleActionResultValidationError is the validation error returned by
// ScheduleActionResult.Validate if the designated constraints aren't met.
type ScheduleActionResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScheduleActionResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScheduleActionResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScheduleActionResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScheduleActionResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScheduleActionResultValidationError) ErrorName() string {
	return "ScheduleActionResultValidationError"
}

// Error satisfies the builtin error interface
func (e ScheduleActionResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScheduleActionResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScheduleActionResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScheduleActionResultValidationError{}

// Validate checks the field values on ScheduleState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScheduleState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScheduleState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScheduleStateMultiError, or
// nil if none found.
func (m *ScheduleState) ValidateAll() error {
	return m.validate(true)
}

func (m *ScheduleState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Notes

	// no validation rules for Paused

	// no validation rules for LimitedActions

	// no validation rules for RemainingActions

	if len(errors) > 0 {
		return ScheduleStateMultiError(errors)
	}

	return nil
}

// ScheduleStateMultiError is an error wrapping multiple validation errors
// returned by ScheduleState.ValidateAll() if the designated constraints
// aren't met.
type ScheduleStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScheduleStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScheduleStateMultiError) AllErrors() []error { return m }

// ScheduleStateValidationError is the validation error returned by
// ScheduleState.Validate if the designated constraints aren't met.
type ScheduleStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScheduleStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScheduleStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScheduleStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScheduleStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScheduleStateValidationError) ErrorName() string { return "ScheduleStateValidationError" }

// Error satisfies the builtin error interface
func (e ScheduleStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScheduleState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScheduleStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScheduleStateValidationError{}

// Validate checks the field values on TriggerImmediatelyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TriggerImmediatelyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TriggerImmediatelyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TriggerImmediatelyRequestMultiError, or nil if none found.
func (m *TriggerImmediatelyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TriggerImmediatelyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OverlapPolicy

	if len(errors) > 0 {
		return TriggerImmediatelyRequestMultiError(errors)
	}

	return nil
}

// TriggerImmediatelyRequestMultiError is an error wrapping multiple validation
// errors returned by TriggerImmediatelyRequest.ValidateAll() if the
// designated constraints aren't met.
type TriggerImmediatelyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TriggerImmediatelyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TriggerImmediatelyRequestMultiError) AllErrors() []error { return m }

// TriggerImmediatelyRequestValidationError is the validation error returned by
// TriggerImmediatelyRequest.Validate if the designated constraints aren't met.
type TriggerImmediatelyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TriggerImmediatelyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TriggerImmediatelyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TriggerImmediatelyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TriggerImmediatelyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TriggerImmediatelyRequestValidationError) ErrorName() string {
	return "TriggerImmediatelyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TriggerImmediatelyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTriggerImmediatelyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TriggerImmediatelyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TriggerImmediatelyRequestValidationError{}

// Validate checks the field values on BackfillRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BackfillRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BackfillRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BackfillRequestMultiError, or nil if none found.
func (m *BackfillRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BackfillRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BackfillRequestValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BackfillRequestValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BackfillRequestValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BackfillRequestValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BackfillRequestValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BackfillRequestValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OverlapPolicy

	if len(errors) > 0 {
		return BackfillRequestMultiError(errors)
	}

	return nil
}

// BackfillRequestMultiError is an error wrapping multiple validation errors
// returned by BackfillRequest.ValidateAll() if the designated constraints
// aren't met.
type BackfillRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BackfillRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BackfillRequestMultiError) AllErrors() []error { return m }

// BackfillRequestValidationError is the validation error returned by
// BackfillRequest.Validate if the designated constraints aren't met.
type BackfillRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BackfillRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BackfillRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BackfillRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BackfillRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BackfillRequestValidationError) ErrorName() string { return "BackfillRequestValidationError" }

// Error satisfies the builtin error interface
func (e BackfillRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBackfillRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BackfillRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BackfillRequestValidationError{}

// Validate checks the field values on SchedulePatch with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SchedulePatch) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SchedulePatch with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SchedulePatchMultiError, or
// nil if none found.
func (m *SchedulePatch) ValidateAll() error {
	return m.validate(true)
}

func (m *SchedulePatch) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTriggerImmediately()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SchedulePatchValidationError{
					field:  "TriggerImmediately",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SchedulePatchValidationError{
					field:  "TriggerImmediately",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTriggerImmediately()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SchedulePatchValidationError{
				field:  "TriggerImmediately",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetBackfillRequest() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SchedulePatchValidationError{
						field:  fmt.Sprintf("BackfillRequest[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SchedulePatchValidationError{
						field:  fmt.Sprintf("BackfillRequest[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SchedulePatchValidationError{
					field:  fmt.Sprintf("BackfillRequest[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Pause

	// no validation rules for Unpause

	if len(errors) > 0 {
		return SchedulePatchMultiError(errors)
	}

	return nil
}

// SchedulePatchMultiError is an error wrapping multiple validation errors
// returned by SchedulePatch.ValidateAll() if the designated constraints
// aren't met.
type SchedulePatchMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SchedulePatchMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SchedulePatchMultiError) AllErrors() []error { return m }

// SchedulePatchValidationError is the validation error returned by
// SchedulePatch.Validate if the designated constraints aren't met.
type SchedulePatchValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SchedulePatchValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SchedulePatchValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SchedulePatchValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SchedulePatchValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SchedulePatchValidationError) ErrorName() string { return "SchedulePatchValidationError" }

// Error satisfies the builtin error interface
func (e SchedulePatchValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSchedulePatch.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SchedulePatchValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SchedulePatchValidationError{}

// Validate checks the field values on ScheduleInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScheduleInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScheduleInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScheduleInfoMultiError, or
// nil if none found.
func (m *ScheduleInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ScheduleInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ActionCount

	// no validation rules for MissedCatchupWindow

	// no validation rules for OverlapSkipped

	for idx, item := range m.GetRunningWorkflows() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ScheduleInfoValidationError{
						field:  fmt.Sprintf("RunningWorkflows[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ScheduleInfoValidationError{
						field:  fmt.Sprintf("RunningWorkflows[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScheduleInfoValidationError{
					field:  fmt.Sprintf("RunningWorkflows[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetRecentActions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ScheduleInfoValidationError{
						field:  fmt.Sprintf("RecentActions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ScheduleInfoValidationError{
						field:  fmt.Sprintf("RecentActions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScheduleInfoValidationError{
					field:  fmt.Sprintf("RecentActions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFutureActionTimes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ScheduleInfoValidationError{
						field:  fmt.Sprintf("FutureActionTimes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ScheduleInfoValidationError{
						field:  fmt.Sprintf("FutureActionTimes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScheduleInfoValidationError{
					field:  fmt.Sprintf("FutureActionTimes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleInfoValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleInfoValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleInfoValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleInfoValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleInfoValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleInfoValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InvalidScheduleError

	if len(errors) > 0 {
		return ScheduleInfoMultiError(errors)
	}

	return nil
}

// ScheduleInfoMultiError is an error wrapping multiple validation errors
// returned by ScheduleInfo.ValidateAll() if the designated constraints aren't met.
type ScheduleInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScheduleInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScheduleInfoMultiError) AllErrors() []error { return m }

// ScheduleInfoValidationError is the validation error returned by
// ScheduleInfo.Validate if the designated constraints aren't met.
type ScheduleInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScheduleInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScheduleInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScheduleInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScheduleInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScheduleInfoValidationError) ErrorName() string { return "ScheduleInfoValidationError" }

// Error satisfies the builtin error interface
func (e ScheduleInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScheduleInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScheduleInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScheduleInfoValidationError{}

// Validate checks the field values on Schedule with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Schedule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Schedule with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScheduleMultiError, or nil
// if none found.
func (m *Schedule) ValidateAll() error {
	return m.validate(true)
}

func (m *Schedule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleValidationError{
				field:  "Action",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPolicies()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleValidationError{
					field:  "Policies",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleValidationError{
					field:  "Policies",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPolicies()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleValidationError{
				field:  "Policies",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ScheduleMultiError(errors)
	}

	return nil
}

// ScheduleMultiError is an error wrapping multiple validation errors returned
// by Schedule.ValidateAll() if the designated constraints aren't met.
type ScheduleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScheduleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScheduleMultiError) AllErrors() []error { return m }

// ScheduleValidationError is the validation error returned by
// Schedule.Validate if the designated constraints aren't met.
type ScheduleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScheduleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScheduleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScheduleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScheduleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScheduleValidationError) ErrorName() string { return "ScheduleValidationError" }

// Error satisfies the builtin error interface
func (e ScheduleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSchedule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScheduleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScheduleValidationError{}

// Validate checks the field values on ScheduleListInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ScheduleListInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScheduleListInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ScheduleListInfoMultiError, or nil if none found.
func (m *ScheduleListInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ScheduleListInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleListInfoValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleListInfoValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleListInfoValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWorkflowType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleListInfoValidationError{
					field:  "WorkflowType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleListInfoValidationError{
					field:  "WorkflowType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWorkflowType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleListInfoValidationError{
				field:  "WorkflowType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Notes

	// no validation rules for Paused

	for idx, item := range m.GetRecentActions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ScheduleListInfoValidationError{
						field:  fmt.Sprintf("RecentActions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ScheduleListInfoValidationError{
						field:  fmt.Sprintf("RecentActions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScheduleListInfoValidationError{
					field:  fmt.Sprintf("RecentActions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFutureActionTimes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ScheduleListInfoValidationError{
						field:  fmt.Sprintf("FutureActionTimes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ScheduleListInfoValidationError{
						field:  fmt.Sprintf("FutureActionTimes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScheduleListInfoValidationError{
					field:  fmt.Sprintf("FutureActionTimes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ScheduleListInfoMultiError(errors)
	}

	return nil
}

// ScheduleListInfoMultiError is an error wrapping multiple validation errors
// returned by ScheduleListInfo.ValidateAll() if the designated constraints
// aren't met.
type ScheduleListInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScheduleListInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScheduleListInfoMultiError) AllErrors() []error { return m }

// ScheduleListInfoValidationError is the validation error returned by
// ScheduleListInfo.Validate if the designated constraints aren't met.
type ScheduleListInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScheduleListInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScheduleListInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScheduleListInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScheduleListInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScheduleListInfoValidationError) ErrorName() string { return "ScheduleListInfoValidationError" }

// Error satisfies the builtin error interface
func (e ScheduleListInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScheduleListInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScheduleListInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScheduleListInfoValidationError{}

// Validate checks the field values on ScheduleListEntry with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ScheduleListEntry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScheduleListEntry with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ScheduleListEntryMultiError, or nil if none found.
func (m *ScheduleListEntry) ValidateAll() error {
	return m.validate(true)
}

func (m *ScheduleListEntry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScheduleId

	if all {
		switch v := interface{}(m.GetMemo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleListEntryValidationError{
					field:  "Memo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleListEntryValidationError{
					field:  "Memo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMemo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleListEntryValidationError{
				field:  "Memo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSearchAttributes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleListEntryValidationError{
					field:  "SearchAttributes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleListEntryValidationError{
					field:  "SearchAttributes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSearchAttributes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleListEntryValidationError{
				field:  "SearchAttributes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScheduleListEntryValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScheduleListEntryValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScheduleListEntryValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ScheduleListEntryMultiError(errors)
	}

	return nil
}

// ScheduleListEntryMultiError is an error wrapping multiple validation errors
// returned by ScheduleListEntry.ValidateAll() if the designated constraints
// aren't met.
type ScheduleListEntryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScheduleListEntryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScheduleListEntryMultiError) AllErrors() []error { return m }

// ScheduleListEntryValidationError is the validation error returned by
// ScheduleListEntry.Validate if the designated constraints aren't met.
type ScheduleListEntryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScheduleListEntryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScheduleListEntryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScheduleListEntryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScheduleListEntryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScheduleListEntryValidationError) ErrorName() string {
	return "ScheduleListEntryValidationError"
}

// Error satisfies the builtin error interface
func (e ScheduleListEntryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScheduleListEntry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScheduleListEntryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScheduleListEntryValidationError{}
