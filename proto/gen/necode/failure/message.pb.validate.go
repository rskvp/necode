// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: necode/failure/message.proto

package failure

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	enums "github.com/rskvp/necode/proto/gen/necode/enums"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = enums.TimeoutType(0)
)

// Validate checks the field values on ApplicationFailureInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplicationFailureInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationFailureInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationFailureInfoMultiError, or nil if none found.
func (m *ApplicationFailureInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationFailureInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for NonRetryable

	if all {
		switch v := interface{}(m.GetDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationFailureInfoValidationError{
					field:  "Details",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationFailureInfoValidationError{
					field:  "Details",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationFailureInfoValidationError{
				field:  "Details",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ApplicationFailureInfoMultiError(errors)
	}

	return nil
}

// ApplicationFailureInfoMultiError is an error wrapping multiple validation
// errors returned by ApplicationFailureInfo.ValidateAll() if the designated
// constraints aren't met.
type ApplicationFailureInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationFailureInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationFailureInfoMultiError) AllErrors() []error { return m }

// ApplicationFailureInfoValidationError is the validation error returned by
// ApplicationFailureInfo.Validate if the designated constraints aren't met.
type ApplicationFailureInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationFailureInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationFailureInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationFailureInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationFailureInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationFailureInfoValidationError) ErrorName() string {
	return "ApplicationFailureInfoValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationFailureInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationFailureInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationFailureInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationFailureInfoValidationError{}

// Validate checks the field values on TimeoutFailureInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TimeoutFailureInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeoutFailureInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TimeoutFailureInfoMultiError, or nil if none found.
func (m *TimeoutFailureInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeoutFailureInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TimeoutType

	if all {
		switch v := interface{}(m.GetLastHeartbeatDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeoutFailureInfoValidationError{
					field:  "LastHeartbeatDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeoutFailureInfoValidationError{
					field:  "LastHeartbeatDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastHeartbeatDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeoutFailureInfoValidationError{
				field:  "LastHeartbeatDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TimeoutFailureInfoMultiError(errors)
	}

	return nil
}

// TimeoutFailureInfoMultiError is an error wrapping multiple validation errors
// returned by TimeoutFailureInfo.ValidateAll() if the designated constraints
// aren't met.
type TimeoutFailureInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeoutFailureInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeoutFailureInfoMultiError) AllErrors() []error { return m }

// TimeoutFailureInfoValidationError is the validation error returned by
// TimeoutFailureInfo.Validate if the designated constraints aren't met.
type TimeoutFailureInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeoutFailureInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeoutFailureInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeoutFailureInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeoutFailureInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeoutFailureInfoValidationError) ErrorName() string {
	return "TimeoutFailureInfoValidationError"
}

// Error satisfies the builtin error interface
func (e TimeoutFailureInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeoutFailureInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeoutFailureInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeoutFailureInfoValidationError{}

// Validate checks the field values on CanceledFailureInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CanceledFailureInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CanceledFailureInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CanceledFailureInfoMultiError, or nil if none found.
func (m *CanceledFailureInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CanceledFailureInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CanceledFailureInfoValidationError{
					field:  "Details",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CanceledFailureInfoValidationError{
					field:  "Details",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CanceledFailureInfoValidationError{
				field:  "Details",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CanceledFailureInfoMultiError(errors)
	}

	return nil
}

// CanceledFailureInfoMultiError is an error wrapping multiple validation
// errors returned by CanceledFailureInfo.ValidateAll() if the designated
// constraints aren't met.
type CanceledFailureInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CanceledFailureInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CanceledFailureInfoMultiError) AllErrors() []error { return m }

// CanceledFailureInfoValidationError is the validation error returned by
// CanceledFailureInfo.Validate if the designated constraints aren't met.
type CanceledFailureInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CanceledFailureInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CanceledFailureInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CanceledFailureInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CanceledFailureInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CanceledFailureInfoValidationError) ErrorName() string {
	return "CanceledFailureInfoValidationError"
}

// Error satisfies the builtin error interface
func (e CanceledFailureInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCanceledFailureInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CanceledFailureInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CanceledFailureInfoValidationError{}

// Validate checks the field values on TerminatedFailureInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TerminatedFailureInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TerminatedFailureInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TerminatedFailureInfoMultiError, or nil if none found.
func (m *TerminatedFailureInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *TerminatedFailureInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TerminatedFailureInfoMultiError(errors)
	}

	return nil
}

// TerminatedFailureInfoMultiError is an error wrapping multiple validation
// errors returned by TerminatedFailureInfo.ValidateAll() if the designated
// constraints aren't met.
type TerminatedFailureInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TerminatedFailureInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TerminatedFailureInfoMultiError) AllErrors() []error { return m }

// TerminatedFailureInfoValidationError is the validation error returned by
// TerminatedFailureInfo.Validate if the designated constraints aren't met.
type TerminatedFailureInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TerminatedFailureInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TerminatedFailureInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TerminatedFailureInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TerminatedFailureInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TerminatedFailureInfoValidationError) ErrorName() string {
	return "TerminatedFailureInfoValidationError"
}

// Error satisfies the builtin error interface
func (e TerminatedFailureInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTerminatedFailureInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TerminatedFailureInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TerminatedFailureInfoValidationError{}

// Validate checks the field values on ServerFailureInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ServerFailureInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServerFailureInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServerFailureInfoMultiError, or nil if none found.
func (m *ServerFailureInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ServerFailureInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NonRetryable

	if len(errors) > 0 {
		return ServerFailureInfoMultiError(errors)
	}

	return nil
}

// ServerFailureInfoMultiError is an error wrapping multiple validation errors
// returned by ServerFailureInfo.ValidateAll() if the designated constraints
// aren't met.
type ServerFailureInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerFailureInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerFailureInfoMultiError) AllErrors() []error { return m }

// ServerFailureInfoValidationError is the validation error returned by
// ServerFailureInfo.Validate if the designated constraints aren't met.
type ServerFailureInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerFailureInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerFailureInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerFailureInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerFailureInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerFailureInfoValidationError) ErrorName() string {
	return "ServerFailureInfoValidationError"
}

// Error satisfies the builtin error interface
func (e ServerFailureInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServerFailureInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerFailureInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerFailureInfoValidationError{}

// Validate checks the field values on ResetWorkflowFailureInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResetWorkflowFailureInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResetWorkflowFailureInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResetWorkflowFailureInfoMultiError, or nil if none found.
func (m *ResetWorkflowFailureInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ResetWorkflowFailureInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLastHeartbeatDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResetWorkflowFailureInfoValidationError{
					field:  "LastHeartbeatDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResetWorkflowFailureInfoValidationError{
					field:  "LastHeartbeatDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastHeartbeatDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResetWorkflowFailureInfoValidationError{
				field:  "LastHeartbeatDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ResetWorkflowFailureInfoMultiError(errors)
	}

	return nil
}

// ResetWorkflowFailureInfoMultiError is an error wrapping multiple validation
// errors returned by ResetWorkflowFailureInfo.ValidateAll() if the designated
// constraints aren't met.
type ResetWorkflowFailureInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResetWorkflowFailureInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResetWorkflowFailureInfoMultiError) AllErrors() []error { return m }

// ResetWorkflowFailureInfoValidationError is the validation error returned by
// ResetWorkflowFailureInfo.Validate if the designated constraints aren't met.
type ResetWorkflowFailureInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResetWorkflowFailureInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResetWorkflowFailureInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResetWorkflowFailureInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResetWorkflowFailureInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResetWorkflowFailureInfoValidationError) ErrorName() string {
	return "ResetWorkflowFailureInfoValidationError"
}

// Error satisfies the builtin error interface
func (e ResetWorkflowFailureInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResetWorkflowFailureInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResetWorkflowFailureInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResetWorkflowFailureInfoValidationError{}

// Validate checks the field values on ActivityFailureInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ActivityFailureInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActivityFailureInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActivityFailureInfoMultiError, or nil if none found.
func (m *ActivityFailureInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ActivityFailureInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScheduledEventId

	// no validation rules for StartedEventId

	// no validation rules for Identity

	if all {
		switch v := interface{}(m.GetActivityType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActivityFailureInfoValidationError{
					field:  "ActivityType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActivityFailureInfoValidationError{
					field:  "ActivityType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActivityType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActivityFailureInfoValidationError{
				field:  "ActivityType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ActivityId

	// no validation rules for RetryState

	if len(errors) > 0 {
		return ActivityFailureInfoMultiError(errors)
	}

	return nil
}

// ActivityFailureInfoMultiError is an error wrapping multiple validation
// errors returned by ActivityFailureInfo.ValidateAll() if the designated
// constraints aren't met.
type ActivityFailureInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActivityFailureInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActivityFailureInfoMultiError) AllErrors() []error { return m }

// ActivityFailureInfoValidationError is the validation error returned by
// ActivityFailureInfo.Validate if the designated constraints aren't met.
type ActivityFailureInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActivityFailureInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActivityFailureInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActivityFailureInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActivityFailureInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActivityFailureInfoValidationError) ErrorName() string {
	return "ActivityFailureInfoValidationError"
}

// Error satisfies the builtin error interface
func (e ActivityFailureInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActivityFailureInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActivityFailureInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActivityFailureInfoValidationError{}

// Validate checks the field values on ChildWorkflowExecutionFailureInfo with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ChildWorkflowExecutionFailureInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChildWorkflowExecutionFailureInfo
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ChildWorkflowExecutionFailureInfoMultiError, or nil if none found.
func (m *ChildWorkflowExecutionFailureInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ChildWorkflowExecutionFailureInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Namespace

	if all {
		switch v := interface{}(m.GetWorkflowExecution()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChildWorkflowExecutionFailureInfoValidationError{
					field:  "WorkflowExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChildWorkflowExecutionFailureInfoValidationError{
					field:  "WorkflowExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWorkflowExecution()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChildWorkflowExecutionFailureInfoValidationError{
				field:  "WorkflowExecution",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWorkflowType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChildWorkflowExecutionFailureInfoValidationError{
					field:  "WorkflowType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChildWorkflowExecutionFailureInfoValidationError{
					field:  "WorkflowType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWorkflowType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChildWorkflowExecutionFailureInfoValidationError{
				field:  "WorkflowType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InitiatedEventId

	// no validation rules for StartedEventId

	// no validation rules for RetryState

	if len(errors) > 0 {
		return ChildWorkflowExecutionFailureInfoMultiError(errors)
	}

	return nil
}

// ChildWorkflowExecutionFailureInfoMultiError is an error wrapping multiple
// validation errors returned by
// ChildWorkflowExecutionFailureInfo.ValidateAll() if the designated
// constraints aren't met.
type ChildWorkflowExecutionFailureInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChildWorkflowExecutionFailureInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChildWorkflowExecutionFailureInfoMultiError) AllErrors() []error { return m }

// ChildWorkflowExecutionFailureInfoValidationError is the validation error
// returned by ChildWorkflowExecutionFailureInfo.Validate if the designated
// constraints aren't met.
type ChildWorkflowExecutionFailureInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChildWorkflowExecutionFailureInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChildWorkflowExecutionFailureInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChildWorkflowExecutionFailureInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChildWorkflowExecutionFailureInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChildWorkflowExecutionFailureInfoValidationError) ErrorName() string {
	return "ChildWorkflowExecutionFailureInfoValidationError"
}

// Error satisfies the builtin error interface
func (e ChildWorkflowExecutionFailureInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChildWorkflowExecutionFailureInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChildWorkflowExecutionFailureInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChildWorkflowExecutionFailureInfoValidationError{}

// Validate checks the field values on Failure with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Failure) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Failure with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in FailureMultiError, or nil if none found.
func (m *Failure) ValidateAll() error {
	return m.validate(true)
}

func (m *Failure) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	// no validation rules for Source

	// no validation rules for StackTrace

	if all {
		switch v := interface{}(m.GetEncodedAttributes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FailureValidationError{
					field:  "EncodedAttributes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FailureValidationError{
					field:  "EncodedAttributes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEncodedAttributes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FailureValidationError{
				field:  "EncodedAttributes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCause()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FailureValidationError{
					field:  "Cause",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FailureValidationError{
					field:  "Cause",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCause()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FailureValidationError{
				field:  "Cause",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.FailureInfo.(type) {
	case *Failure_ApplicationFailureInfo:
		if v == nil {
			err := FailureValidationError{
				field:  "FailureInfo",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApplicationFailureInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FailureValidationError{
						field:  "ApplicationFailureInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FailureValidationError{
						field:  "ApplicationFailureInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApplicationFailureInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FailureValidationError{
					field:  "ApplicationFailureInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Failure_TimeoutFailureInfo:
		if v == nil {
			err := FailureValidationError{
				field:  "FailureInfo",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTimeoutFailureInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FailureValidationError{
						field:  "TimeoutFailureInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FailureValidationError{
						field:  "TimeoutFailureInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTimeoutFailureInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FailureValidationError{
					field:  "TimeoutFailureInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Failure_CanceledFailureInfo:
		if v == nil {
			err := FailureValidationError{
				field:  "FailureInfo",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCanceledFailureInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FailureValidationError{
						field:  "CanceledFailureInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FailureValidationError{
						field:  "CanceledFailureInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCanceledFailureInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FailureValidationError{
					field:  "CanceledFailureInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Failure_TerminatedFailureInfo:
		if v == nil {
			err := FailureValidationError{
				field:  "FailureInfo",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTerminatedFailureInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FailureValidationError{
						field:  "TerminatedFailureInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FailureValidationError{
						field:  "TerminatedFailureInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTerminatedFailureInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FailureValidationError{
					field:  "TerminatedFailureInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Failure_ServerFailureInfo:
		if v == nil {
			err := FailureValidationError{
				field:  "FailureInfo",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetServerFailureInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FailureValidationError{
						field:  "ServerFailureInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FailureValidationError{
						field:  "ServerFailureInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetServerFailureInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FailureValidationError{
					field:  "ServerFailureInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Failure_ResetWorkflowFailureInfo:
		if v == nil {
			err := FailureValidationError{
				field:  "FailureInfo",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetResetWorkflowFailureInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FailureValidationError{
						field:  "ResetWorkflowFailureInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FailureValidationError{
						field:  "ResetWorkflowFailureInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResetWorkflowFailureInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FailureValidationError{
					field:  "ResetWorkflowFailureInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Failure_ActivityFailureInfo:
		if v == nil {
			err := FailureValidationError{
				field:  "FailureInfo",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetActivityFailureInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FailureValidationError{
						field:  "ActivityFailureInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FailureValidationError{
						field:  "ActivityFailureInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActivityFailureInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FailureValidationError{
					field:  "ActivityFailureInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Failure_ChildWorkflowExecutionFailureInfo:
		if v == nil {
			err := FailureValidationError{
				field:  "FailureInfo",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetChildWorkflowExecutionFailureInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FailureValidationError{
						field:  "ChildWorkflowExecutionFailureInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FailureValidationError{
						field:  "ChildWorkflowExecutionFailureInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetChildWorkflowExecutionFailureInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FailureValidationError{
					field:  "ChildWorkflowExecutionFailureInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return FailureMultiError(errors)
	}

	return nil
}

// FailureMultiError is an error wrapping multiple validation errors returned
// by Failure.ValidateAll() if the designated constraints aren't met.
type FailureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FailureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FailureMultiError) AllErrors() []error { return m }

// FailureValidationError is the validation error returned by Failure.Validate
// if the designated constraints aren't met.
type FailureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FailureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FailureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FailureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FailureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FailureValidationError) ErrorName() string { return "FailureValidationError" }

// Error satisfies the builtin error interface
func (e FailureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFailure.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FailureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FailureValidationError{}
