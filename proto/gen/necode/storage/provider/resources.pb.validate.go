// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: necode/storage/provider/resources.proto

package provider

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ResourceInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResourceInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceInfoMultiError, or
// nil if none found.
func (m *ResourceInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOpaque()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpaque()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceInfoValidationError{
				field:  "Opaque",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceInfoValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetChecksum()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "Checksum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "Checksum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetChecksum()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceInfoValidationError{
				field:  "Checksum",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	// no validation rules for MimeType

	if all {
		switch v := interface{}(m.GetMtime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "Mtime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "Mtime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMtime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceInfoValidationError{
				field:  "Mtime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Path

	if all {
		switch v := interface{}(m.GetPermissionSet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "PermissionSet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "PermissionSet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPermissionSet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceInfoValidationError{
				field:  "PermissionSet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Size

	if all {
		switch v := interface{}(m.GetOwner()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOwner()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceInfoValidationError{
				field:  "Owner",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Target

	if all {
		switch v := interface{}(m.GetCanonicalMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "CanonicalMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "CanonicalMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCanonicalMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceInfoValidationError{
				field:  "CanonicalMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetArbitraryMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "ArbitraryMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "ArbitraryMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetArbitraryMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceInfoValidationError{
				field:  "ArbitraryMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLock()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "Lock",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "Lock",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLock()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceInfoValidationError{
				field:  "Lock",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetAdvisoryLocks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceInfoValidationError{
						field:  fmt.Sprintf("AdvisoryLocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceInfoValidationError{
						field:  fmt.Sprintf("AdvisoryLocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceInfoValidationError{
					field:  fmt.Sprintf("AdvisoryLocks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetParentId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "ParentId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "ParentId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParentId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceInfoValidationError{
				field:  "ParentId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetSpace()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "Space",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceInfoValidationError{
					field:  "Space",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpace()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceInfoValidationError{
				field:  "Space",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ResourceInfoMultiError(errors)
	}

	return nil
}

// ResourceInfoMultiError is an error wrapping multiple validation errors
// returned by ResourceInfo.ValidateAll() if the designated constraints aren't met.
type ResourceInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceInfoMultiError) AllErrors() []error { return m }

// ResourceInfoValidationError is the validation error returned by
// ResourceInfo.Validate if the designated constraints aren't met.
type ResourceInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceInfoValidationError) ErrorName() string { return "ResourceInfoValidationError" }

// Error satisfies the builtin error interface
func (e ResourceInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceInfoValidationError{}

// Validate checks the field values on CanonicalMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CanonicalMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CanonicalMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CanonicalMetadataMultiError, or nil if none found.
func (m *CanonicalMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *CanonicalMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CanonicalMetadataValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CanonicalMetadataValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CanonicalMetadataValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CanonicalMetadataMultiError(errors)
	}

	return nil
}

// CanonicalMetadataMultiError is an error wrapping multiple validation errors
// returned by CanonicalMetadata.ValidateAll() if the designated constraints
// aren't met.
type CanonicalMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CanonicalMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CanonicalMetadataMultiError) AllErrors() []error { return m }

// CanonicalMetadataValidationError is the validation error returned by
// CanonicalMetadata.Validate if the designated constraints aren't met.
type CanonicalMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CanonicalMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CanonicalMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CanonicalMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CanonicalMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CanonicalMetadataValidationError) ErrorName() string {
	return "CanonicalMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e CanonicalMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCanonicalMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CanonicalMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CanonicalMetadataValidationError{}

// Validate checks the field values on ArbitraryMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ArbitraryMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ArbitraryMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ArbitraryMetadataMultiError, or nil if none found.
func (m *ArbitraryMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *ArbitraryMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Metadata

	if len(errors) > 0 {
		return ArbitraryMetadataMultiError(errors)
	}

	return nil
}

// ArbitraryMetadataMultiError is an error wrapping multiple validation errors
// returned by ArbitraryMetadata.ValidateAll() if the designated constraints
// aren't met.
type ArbitraryMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArbitraryMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArbitraryMetadataMultiError) AllErrors() []error { return m }

// ArbitraryMetadataValidationError is the validation error returned by
// ArbitraryMetadata.Validate if the designated constraints aren't met.
type ArbitraryMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArbitraryMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArbitraryMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArbitraryMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArbitraryMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArbitraryMetadataValidationError) ErrorName() string {
	return "ArbitraryMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e ArbitraryMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArbitraryMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArbitraryMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArbitraryMetadataValidationError{}

// Validate checks the field values on Lock with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Lock) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Lock with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LockMultiError, or nil if none found.
func (m *Lock) ValidateAll() error {
	return m.validate(true)
}

func (m *Lock) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOpaque()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LockValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LockValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpaque()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LockValidationError{
				field:  "Opaque",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LockId

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LockValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LockValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LockValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AppName

	if all {
		switch v := interface{}(m.GetExpiration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LockValidationError{
					field:  "Expiration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LockValidationError{
					field:  "Expiration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LockValidationError{
				field:  "Expiration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LockMultiError(errors)
	}

	return nil
}

// LockMultiError is an error wrapping multiple validation errors returned by
// Lock.ValidateAll() if the designated constraints aren't met.
type LockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LockMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LockMultiError) AllErrors() []error { return m }

// LockValidationError is the validation error returned by Lock.Validate if the
// designated constraints aren't met.
type LockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LockValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LockValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LockValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LockValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LockValidationError) ErrorName() string { return "LockValidationError" }

// Error satisfies the builtin error interface
func (e LockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LockValidationError{}

// Validate checks the field values on ResourceChecksum with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ResourceChecksum) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceChecksum with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResourceChecksumMultiError, or nil if none found.
func (m *ResourceChecksum) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceChecksum) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Sum

	if len(errors) > 0 {
		return ResourceChecksumMultiError(errors)
	}

	return nil
}

// ResourceChecksumMultiError is an error wrapping multiple validation errors
// returned by ResourceChecksum.ValidateAll() if the designated constraints
// aren't met.
type ResourceChecksumMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceChecksumMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceChecksumMultiError) AllErrors() []error { return m }

// ResourceChecksumValidationError is the validation error returned by
// ResourceChecksum.Validate if the designated constraints aren't met.
type ResourceChecksumValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceChecksumValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceChecksumValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceChecksumValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceChecksumValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceChecksumValidationError) ErrorName() string { return "ResourceChecksumValidationError" }

// Error satisfies the builtin error interface
func (e ResourceChecksumValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceChecksum.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceChecksumValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceChecksumValidationError{}

// Validate checks the field values on ResourceChecksumPriority with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResourceChecksumPriority) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceChecksumPriority with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResourceChecksumPriorityMultiError, or nil if none found.
func (m *ResourceChecksumPriority) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceChecksumPriority) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Priority

	if len(errors) > 0 {
		return ResourceChecksumPriorityMultiError(errors)
	}

	return nil
}

// ResourceChecksumPriorityMultiError is an error wrapping multiple validation
// errors returned by ResourceChecksumPriority.ValidateAll() if the designated
// constraints aren't met.
type ResourceChecksumPriorityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceChecksumPriorityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceChecksumPriorityMultiError) AllErrors() []error { return m }

// ResourceChecksumPriorityValidationError is the validation error returned by
// ResourceChecksumPriority.Validate if the designated constraints aren't met.
type ResourceChecksumPriorityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceChecksumPriorityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceChecksumPriorityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceChecksumPriorityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceChecksumPriorityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceChecksumPriorityValidationError) ErrorName() string {
	return "ResourceChecksumPriorityValidationError"
}

// Error satisfies the builtin error interface
func (e ResourceChecksumPriorityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceChecksumPriority.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceChecksumPriorityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceChecksumPriorityValidationError{}

// Validate checks the field values on Reference with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Reference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Reference with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReferenceMultiError, or nil
// if none found.
func (m *Reference) ValidateAll() error {
	return m.validate(true)
}

func (m *Reference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetResourceId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReferenceValidationError{
					field:  "ResourceId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReferenceValidationError{
					field:  "ResourceId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResourceId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReferenceValidationError{
				field:  "ResourceId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Path

	if len(errors) > 0 {
		return ReferenceMultiError(errors)
	}

	return nil
}

// ReferenceMultiError is an error wrapping multiple validation errors returned
// by Reference.ValidateAll() if the designated constraints aren't met.
type ReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceMultiError) AllErrors() []error { return m }

// ReferenceValidationError is the validation error returned by
// Reference.Validate if the designated constraints aren't met.
type ReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceValidationError) ErrorName() string { return "ReferenceValidationError" }

// Error satisfies the builtin error interface
func (e ReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceValidationError{}

// Validate checks the field values on ResourceId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResourceId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceId with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceIdMultiError, or
// nil if none found.
func (m *ResourceId) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StorageId

	// no validation rules for OpaqueId

	// no validation rules for SpaceId

	if len(errors) > 0 {
		return ResourceIdMultiError(errors)
	}

	return nil
}

// ResourceIdMultiError is an error wrapping multiple validation errors
// returned by ResourceId.ValidateAll() if the designated constraints aren't met.
type ResourceIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceIdMultiError) AllErrors() []error { return m }

// ResourceIdValidationError is the validation error returned by
// ResourceId.Validate if the designated constraints aren't met.
type ResourceIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceIdValidationError) ErrorName() string { return "ResourceIdValidationError" }

// Error satisfies the builtin error interface
func (e ResourceIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceIdValidationError{}

// Validate checks the field values on ResourcePermissions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResourcePermissions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourcePermissions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResourcePermissionsMultiError, or nil if none found.
func (m *ResourcePermissions) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourcePermissions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AddGrant

	// no validation rules for CreateContainer

	// no validation rules for Delete

	// no validation rules for GetPath

	// no validation rules for GetQuota

	// no validation rules for InitiateFileDownload

	// no validation rules for InitiateFileUpload

	// no validation rules for ListGrants

	// no validation rules for ListContainer

	// no validation rules for ListFileVersions

	// no validation rules for ListRecycle

	// no validation rules for Move

	// no validation rules for RemoveGrant

	// no validation rules for PurgeRecycle

	// no validation rules for RestoreFileVersion

	// no validation rules for RestoreRecycleItem

	// no validation rules for Stat

	// no validation rules for UpdateGrant

	// no validation rules for DenyGrant

	if len(errors) > 0 {
		return ResourcePermissionsMultiError(errors)
	}

	return nil
}

// ResourcePermissionsMultiError is an error wrapping multiple validation
// errors returned by ResourcePermissions.ValidateAll() if the designated
// constraints aren't met.
type ResourcePermissionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourcePermissionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourcePermissionsMultiError) AllErrors() []error { return m }

// ResourcePermissionsValidationError is the validation error returned by
// ResourcePermissions.Validate if the designated constraints aren't met.
type ResourcePermissionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourcePermissionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourcePermissionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourcePermissionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourcePermissionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourcePermissionsValidationError) ErrorName() string {
	return "ResourcePermissionsValidationError"
}

// Error satisfies the builtin error interface
func (e ResourcePermissionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourcePermissions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourcePermissionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourcePermissionsValidationError{}

// Validate checks the field values on Grant with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Grant) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Grant with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GrantMultiError, or nil if none found.
func (m *Grant) ValidateAll() error {
	return m.validate(true)
}

func (m *Grant) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGrantee()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GrantValidationError{
					field:  "Grantee",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GrantValidationError{
					field:  "Grantee",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGrantee()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GrantValidationError{
				field:  "Grantee",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPermissions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GrantValidationError{
					field:  "Permissions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GrantValidationError{
					field:  "Permissions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPermissions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GrantValidationError{
				field:  "Permissions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreator()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GrantValidationError{
					field:  "Creator",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GrantValidationError{
					field:  "Creator",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreator()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GrantValidationError{
				field:  "Creator",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExpiration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GrantValidationError{
					field:  "Expiration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GrantValidationError{
					field:  "Expiration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GrantValidationError{
				field:  "Expiration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GrantMultiError(errors)
	}

	return nil
}

// GrantMultiError is an error wrapping multiple validation errors returned by
// Grant.ValidateAll() if the designated constraints aren't met.
type GrantMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GrantMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GrantMultiError) AllErrors() []error { return m }

// GrantValidationError is the validation error returned by Grant.Validate if
// the designated constraints aren't met.
type GrantValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GrantValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GrantValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GrantValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GrantValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GrantValidationError) ErrorName() string { return "GrantValidationError" }

// Error satisfies the builtin error interface
func (e GrantValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGrant.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GrantValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GrantValidationError{}

// Validate checks the field values on Grantee with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Grantee) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Grantee with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GranteeMultiError, or nil if none found.
func (m *Grantee) ValidateAll() error {
	return m.validate(true)
}

func (m *Grantee) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetOpaque()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GranteeValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GranteeValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpaque()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GranteeValidationError{
				field:  "Opaque",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Id.(type) {
	case *Grantee_UserId:
		if v == nil {
			err := GranteeValidationError{
				field:  "Id",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUserId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GranteeValidationError{
						field:  "UserId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GranteeValidationError{
						field:  "UserId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUserId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GranteeValidationError{
					field:  "UserId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Grantee_GroupId:
		if v == nil {
			err := GranteeValidationError{
				field:  "Id",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGroupId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GranteeValidationError{
						field:  "GroupId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GranteeValidationError{
						field:  "GroupId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGroupId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GranteeValidationError{
					field:  "GroupId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return GranteeMultiError(errors)
	}

	return nil
}

// GranteeMultiError is an error wrapping multiple validation errors returned
// by Grantee.ValidateAll() if the designated constraints aren't met.
type GranteeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GranteeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GranteeMultiError) AllErrors() []error { return m }

// GranteeValidationError is the validation error returned by Grantee.Validate
// if the designated constraints aren't met.
type GranteeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GranteeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GranteeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GranteeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GranteeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GranteeValidationError) ErrorName() string { return "GranteeValidationError" }

// Error satisfies the builtin error interface
func (e GranteeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGrantee.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GranteeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GranteeValidationError{}

// Validate checks the field values on FileVersion with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FileVersion) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileVersion with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FileVersionMultiError, or
// nil if none found.
func (m *FileVersion) ValidateAll() error {
	return m.validate(true)
}

func (m *FileVersion) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOpaque()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileVersionValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileVersionValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpaque()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileVersionValidationError{
				field:  "Opaque",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Key

	// no validation rules for Size

	// no validation rules for Mtime

	// no validation rules for Etag

	if len(errors) > 0 {
		return FileVersionMultiError(errors)
	}

	return nil
}

// FileVersionMultiError is an error wrapping multiple validation errors
// returned by FileVersion.ValidateAll() if the designated constraints aren't met.
type FileVersionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileVersionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileVersionMultiError) AllErrors() []error { return m }

// FileVersionValidationError is the validation error returned by
// FileVersion.Validate if the designated constraints aren't met.
type FileVersionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileVersionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileVersionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileVersionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileVersionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileVersionValidationError) ErrorName() string { return "FileVersionValidationError" }

// Error satisfies the builtin error interface
func (e FileVersionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileVersion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileVersionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileVersionValidationError{}

// Validate checks the field values on RecycleItem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RecycleItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RecycleItem with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RecycleItemMultiError, or
// nil if none found.
func (m *RecycleItem) ValidateAll() error {
	return m.validate(true)
}

func (m *RecycleItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOpaque()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RecycleItemValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RecycleItemValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpaque()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RecycleItemValidationError{
				field:  "Opaque",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	// no validation rules for Key

	if all {
		switch v := interface{}(m.GetRef()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RecycleItemValidationError{
					field:  "Ref",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RecycleItemValidationError{
					field:  "Ref",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRef()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RecycleItemValidationError{
				field:  "Ref",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Size

	if all {
		switch v := interface{}(m.GetDeletionTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RecycleItemValidationError{
					field:  "DeletionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RecycleItemValidationError{
					field:  "DeletionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeletionTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RecycleItemValidationError{
				field:  "DeletionTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RecycleItemMultiError(errors)
	}

	return nil
}

// RecycleItemMultiError is an error wrapping multiple validation errors
// returned by RecycleItem.ValidateAll() if the designated constraints aren't met.
type RecycleItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RecycleItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RecycleItemMultiError) AllErrors() []error { return m }

// RecycleItemValidationError is the validation error returned by
// RecycleItem.Validate if the designated constraints aren't met.
type RecycleItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RecycleItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RecycleItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RecycleItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RecycleItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RecycleItemValidationError) ErrorName() string { return "RecycleItemValidationError" }

// Error satisfies the builtin error interface
func (e RecycleItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRecycleItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RecycleItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RecycleItemValidationError{}

// Validate checks the field values on FileUploadProtocol with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FileUploadProtocol) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileUploadProtocol with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FileUploadProtocolMultiError, or nil if none found.
func (m *FileUploadProtocol) ValidateAll() error {
	return m.validate(true)
}

func (m *FileUploadProtocol) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOpaque()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileUploadProtocolValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileUploadProtocolValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpaque()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileUploadProtocolValidationError{
				field:  "Opaque",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Protocol

	// no validation rules for UploadEndpoint

	for idx, item := range m.GetAvailableChecksums() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FileUploadProtocolValidationError{
						field:  fmt.Sprintf("AvailableChecksums[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FileUploadProtocolValidationError{
						field:  fmt.Sprintf("AvailableChecksums[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FileUploadProtocolValidationError{
					field:  fmt.Sprintf("AvailableChecksums[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Expose

	if all {
		switch v := interface{}(m.GetExpiration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileUploadProtocolValidationError{
					field:  "Expiration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileUploadProtocolValidationError{
					field:  "Expiration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileUploadProtocolValidationError{
				field:  "Expiration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FileUploadProtocolMultiError(errors)
	}

	return nil
}

// FileUploadProtocolMultiError is an error wrapping multiple validation errors
// returned by FileUploadProtocol.ValidateAll() if the designated constraints
// aren't met.
type FileUploadProtocolMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileUploadProtocolMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileUploadProtocolMultiError) AllErrors() []error { return m }

// FileUploadProtocolValidationError is the validation error returned by
// FileUploadProtocol.Validate if the designated constraints aren't met.
type FileUploadProtocolValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileUploadProtocolValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileUploadProtocolValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileUploadProtocolValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileUploadProtocolValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileUploadProtocolValidationError) ErrorName() string {
	return "FileUploadProtocolValidationError"
}

// Error satisfies the builtin error interface
func (e FileUploadProtocolValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileUploadProtocol.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileUploadProtocolValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileUploadProtocolValidationError{}

// Validate checks the field values on FileDownloadProtocol with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FileDownloadProtocol) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileDownloadProtocol with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FileDownloadProtocolMultiError, or nil if none found.
func (m *FileDownloadProtocol) ValidateAll() error {
	return m.validate(true)
}

func (m *FileDownloadProtocol) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOpaque()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileDownloadProtocolValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileDownloadProtocolValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpaque()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileDownloadProtocolValidationError{
				field:  "Opaque",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Protocol

	// no validation rules for DownloadEndpoint

	// no validation rules for Expose

	if len(errors) > 0 {
		return FileDownloadProtocolMultiError(errors)
	}

	return nil
}

// FileDownloadProtocolMultiError is an error wrapping multiple validation
// errors returned by FileDownloadProtocol.ValidateAll() if the designated
// constraints aren't met.
type FileDownloadProtocolMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileDownloadProtocolMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileDownloadProtocolMultiError) AllErrors() []error { return m }

// FileDownloadProtocolValidationError is the validation error returned by
// FileDownloadProtocol.Validate if the designated constraints aren't met.
type FileDownloadProtocolValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileDownloadProtocolValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileDownloadProtocolValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileDownloadProtocolValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileDownloadProtocolValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileDownloadProtocolValidationError) ErrorName() string {
	return "FileDownloadProtocolValidationError"
}

// Error satisfies the builtin error interface
func (e FileDownloadProtocolValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileDownloadProtocol.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileDownloadProtocolValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileDownloadProtocolValidationError{}

// Validate checks the field values on StorageSpace with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StorageSpace) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StorageSpace with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StorageSpaceMultiError, or
// nil if none found.
func (m *StorageSpace) ValidateAll() error {
	return m.validate(true)
}

func (m *StorageSpace) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOpaque()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StorageSpaceValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StorageSpaceValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpaque()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StorageSpaceValidationError{
				field:  "Opaque",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StorageSpaceValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StorageSpaceValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StorageSpaceValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOwner()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StorageSpaceValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StorageSpaceValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOwner()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StorageSpaceValidationError{
				field:  "Owner",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRoot()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StorageSpaceValidationError{
					field:  "Root",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StorageSpaceValidationError{
					field:  "Root",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRoot()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StorageSpaceValidationError{
				field:  "Root",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetQuota()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StorageSpaceValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StorageSpaceValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuota()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StorageSpaceValidationError{
				field:  "Quota",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SpaceType

	if all {
		switch v := interface{}(m.GetMtime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StorageSpaceValidationError{
					field:  "Mtime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StorageSpaceValidationError{
					field:  "Mtime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMtime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StorageSpaceValidationError{
				field:  "Mtime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRootInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StorageSpaceValidationError{
					field:  "RootInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StorageSpaceValidationError{
					field:  "RootInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRootInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StorageSpaceValidationError{
				field:  "RootInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StorageSpaceMultiError(errors)
	}

	return nil
}

// StorageSpaceMultiError is an error wrapping multiple validation errors
// returned by StorageSpace.ValidateAll() if the designated constraints aren't met.
type StorageSpaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StorageSpaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StorageSpaceMultiError) AllErrors() []error { return m }

// StorageSpaceValidationError is the validation error returned by
// StorageSpace.Validate if the designated constraints aren't met.
type StorageSpaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StorageSpaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StorageSpaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StorageSpaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StorageSpaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StorageSpaceValidationError) ErrorName() string { return "StorageSpaceValidationError" }

// Error satisfies the builtin error interface
func (e StorageSpaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStorageSpace.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StorageSpaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StorageSpaceValidationError{}

// Validate checks the field values on StorageSpaceId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StorageSpaceId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StorageSpaceId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StorageSpaceIdMultiError,
// or nil if none found.
func (m *StorageSpaceId) ValidateAll() error {
	return m.validate(true)
}

func (m *StorageSpaceId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OpaqueId

	if len(errors) > 0 {
		return StorageSpaceIdMultiError(errors)
	}

	return nil
}

// StorageSpaceIdMultiError is an error wrapping multiple validation errors
// returned by StorageSpaceId.ValidateAll() if the designated constraints
// aren't met.
type StorageSpaceIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StorageSpaceIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StorageSpaceIdMultiError) AllErrors() []error { return m }

// StorageSpaceIdValidationError is the validation error returned by
// StorageSpaceId.Validate if the designated constraints aren't met.
type StorageSpaceIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StorageSpaceIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StorageSpaceIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StorageSpaceIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StorageSpaceIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StorageSpaceIdValidationError) ErrorName() string { return "StorageSpaceIdValidationError" }

// Error satisfies the builtin error interface
func (e StorageSpaceIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStorageSpaceId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StorageSpaceIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StorageSpaceIdValidationError{}

// Validate checks the field values on Quota with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Quota) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Quota with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in QuotaMultiError, or nil if none found.
func (m *Quota) ValidateAll() error {
	return m.validate(true)
}

func (m *Quota) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOpaque()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QuotaValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QuotaValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpaque()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QuotaValidationError{
				field:  "Opaque",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for QuotaMaxBytes

	// no validation rules for QuotaMaxFiles

	if len(errors) > 0 {
		return QuotaMultiError(errors)
	}

	return nil
}

// QuotaMultiError is an error wrapping multiple validation errors returned by
// Quota.ValidateAll() if the designated constraints aren't met.
type QuotaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuotaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuotaMultiError) AllErrors() []error { return m }

// QuotaValidationError is the validation error returned by Quota.Validate if
// the designated constraints aren't met.
type QuotaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuotaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuotaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuotaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuotaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuotaValidationError) ErrorName() string { return "QuotaValidationError" }

// Error satisfies the builtin error interface
func (e QuotaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuota.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuotaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuotaValidationError{}
